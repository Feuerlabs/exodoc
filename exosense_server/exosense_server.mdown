Title:        Exosense Dictionary Design Document

Subtitle:     Version 1.0
Author:       Magnus Feuer (magnus@feuerlabs.com)
Affiliation:  Feuerlabs
Date:         Dec 27, 2011
Copyright:    2011 Feuerlabs Inc. All Rights Reserved.
HTML header:  <script src="support/format_and_toc.js"></script>

# Esosense Dictionary Design Document #
<b>TODO: ADD UPDATE BLOCKS FOR TWO-PHASE-COMMITS</b><br>
<b>TODO: ADD FANCY GRAPHICS</b>

<toc>

# Introduction #
This document specifies the high level design of dictionary of the Exosense system.
The dictionary system allows configration data, software, firmware images and measurements
to be transferred between a device, a manager, and on to a backend system.


# Overview #
The dictionary system is, together with RPCs, the main communication link between a device
and the device manager.

## Entities ##
The system is setup with four major entities.

### Device ###
A single device managed by the system. Each device has a unique ID
and a number of arbitrary attributes.
Each device is member of one or more groups.

### Device Group ###
A collection of devices. Each device group has a name, a device
member list, a data tree, and a data schema. If a device is a member
of multiple groups, the aggregated groups' configuration data trees will
be the config data of the device. Each device will have a unique
group named after the device ID with the device itself as the only member, thus allowing for
individual device addressing.

### Data Tree ###
A tree of containign configuration data values. A data tree always belongs
to one and only one group.

### Data Schema ###
The structure of a data tree, expressed in YANG (RFC 6020). Data schemas also
contains code to execute when specific events occur.
A data schema always belongs to one and only one group.

### Data Store ###
A complete data tree stored on a device. A device can have multiple
data stores (versions) and switch atomically between them using
a built in RPC.

### Dictionary entry addressing ###
A dictionary entry in a data tree can be addressed using the following syntax

  [group]/[version]:[node1]/[node2]/../[noden]

- <b>group</b><br>
  Identifies the group that the address refers to.

- <b>version [Optional]</b><br>
  Specifies the version of the data tree within the group that the address refers to.

- <b>node</b><br>
  A node in the data tree. The final element in the path can be either
  a leaf or a node. If the final element is a node The path will
  address that node and all nodes/leafs stored in it.

## Externally initiated operations ##

A number of external operations can be initiated toward the Device
Manager (DM) either from the or the customer backend server (BS) or
the embedded device (ED). Sometimes an initiated operation results in
the DM modifying the DM or the BS.

- <b>Provision device [BS->DM]</b><br>
  Setup or delete a device in the system. Manages device entities as described above.

- <b>Provision group [BS->DM]</b><br>
  Setup, modifies or deletes groups in the system. Manages groups as described above.

- <b>Provision group membership [BS->DM]</b><br>
  Add and delete devices as group members.

- <b>Set dictionary value [BS->DM->ED | ED->DM->BS]</b><br>
  Set a dictionary value. Depending on how the data schema is setup
  for the dictionary entry, code will get executed on the DM and the
  ED.

- <b>Get dictionary value [BS->DM]</b><br>
  Retrieve a current dictionary value. The value can either be explicitly
  set by the generating device application, or created by monitor code associated
  with the dictionary entry.

- <b>Execute dictionary RPC [BS->DM | ED->DM]</b><br>
  Execute an RPC associated with a data tree entry. The RPC code may execute on the SM, on the
  ED, or on both. The code to execute is specified by the data tree entry

- <b>Execute built in RPC [BS->DM | ED->DM]</b><br>
  Execute RPC code hardwired into an application. If the BS initiates
  the call, it can be intercepted and executed either by the DM
  protocol plugin for the ED, or the ED itself.


# Data Schema Format #
The data schema format is based on a subset of the YANG spec (RFC 6020).

In addition to the standard configuration entries set and read directly
by the application on the device, there are four additional configuration
entry types


## Server RPC Entry ##
A server RPC entry is configuration data containing dynamic code that
can be executed on the DM from the backend server (through JSON) or the device itself
(through BERT-RPC).

The RPC entry is described in the data schmea as a YANG leaf with the
type server_rpc. The RPC code itself, as well as its input/output
signature is stored as configuration data for the given leaf.

When the RPC is invoked, the erlang code is executed on the exosense server.
The values returned by the erlang code is returned to the caller.

A Server RPC schema YANG entry is given below:

    leaf random {
      description "Generate a random value when this entry is invoked as an rpc"

      type: server_rpc
    }

To provision the code and signature for the leaf above, the backend server
sends in the following JSON code to the DM.

    {
      "set": "some_group/1:a/b/c/random,
      "params": {
                  "input": {
                    "Min": uint32
                    "Max": uint32
                  },
                  "output": {
                    "Result": uint32
                  },
                  "code": "Result = random:uniform(Max - Min + 1) + Min - 1."
                },
      "id": 4711,
      "reply-url": "http://client_backend.com:/reply-handler"
    }


The "set" element is used to set configuration data.<br>
The "params" element contains the code, and the input/output signatures.<br>
The "id" is the transaction ID to tag the reply (below) with.
The "reply-url" element specifies where to send the request replies to.

The reply (sent to http://client_backend.com/reply-handler) will be:

    {
      "reply": "final",
      "error_code": 0,
      "error_text": "ok",
      "id": 4711
    }

The "reply" element specifies that this is the final reply for 4711 transaction.<br>
The "error_code" element specifies the numerical error code.<br>
The "error_text" element contains a textual description of the error.<br>
The "id" element is the transaction ID tag from the request.


If a backend server wants to invoke this RPC through a JSON call, it
would send the follwing to the DM.

    {
      "rpc-request": "some_group/1:a/b/c/random",
      "params": {
        "Min": 10,
        "Max": 50
      },
      "id": 4712,
      "ttl": 3600,
      "reply-url": "http://client_backend.com:/reply-handler"
    }


The "rpc-request" element specifies the complete path to the configuration
entry containing the call to execute.<br>
The "params" contains the input parameters to the RPC.<br>
The "id" specifies the transaction ID to tag the reply (below) with.<br>
The "ttl" specifies the time to live (in seconds) for the call. If it has not been executed
within that period of time, it shall be timed out.
The "reply-url" element specifies where to send the request replies to.

The DM will immediately respond to the backend server (at http://client_backend.com/reply-handler) with:

    {
      "rpc-reply": "queued",
      "id": 4711,
    }

The "rpc-reply" element's "queued" value indicates that the requst is queued for execution on the DM.<br>
The "id" is the transaction id tag from the request.

The DM will then execute the configured erlang code and send back a second JSON block
to the backend server:

    {
      "rpc-reply": "final",
      "result": {
         "Result": 42
      },
      "id": 4712,
      "error_code": 0,
      "error_text": "ok",
    }

The "rpc-reply" element's "final" value indicates that this is the last reply for the given request..<br>
The "result" element contains the output from the erlang code exeucution.
The "id" is the transaction id tag from the request.
The "error_code" element specifies the numerical error code.<br>
The "error_text" element contains a textual description of the error.<br>



## Device RPC Entry ##
A device RPC entry is configuration data containing dynamic code that
can be executed on the device from the backend server (through JSON) or the device itself
through a device-local loopback call.

The RPC entry is described in the data schmea as a YANG leaf with the
type device_rpc. The RPC code itself, as well as its input/output
signature is stored as configuration data for the given leaf.

When the RPC is invoked, the erlang code is executed on all exosense devices
that are members of the group that the rpc entry belongs to. Thus, a single
device RPC call sent from the backend server to the DM  may be executed on
millions of devices. The reply from each device will be reported back to the
originating backend server.

A Server RPC schema YANG entry is given below:

    leaf sum_average {
      description "Calculate the sum and the average value of the two input values"
      type: device_rpc
    }

To provision the code and signature for the leaf above, the backend server
sends in the following JSON code to the DM.

    {
      "set": "some_group/1:a/b/c/sum_average,
      "params": {
                  "input": {
                    "Val1": decimal64,
                    "Val2": decimal64
                  },
                  "output": {
                    "Sum": decimal64,
                    "Average": decimal64
                  },
                  "code": "{ Sum, Average } = { Val1 + Val2, (Val1 + Val2) / 2.0 }."
                },
      "id": 4713,
      "reply-url": "http://client_backend.com:/reply-handler"
    }


The "set" element is used to set configuration data.<br>
The "params" element contains the code, and the input/output signatures.<br>
The "id" is the transaction ID to tag the reply (below) with.

The DM will immediately respond to the backend server (at http://client_backend.com/reply-handler) with:

    {
      "reply": "final",
      "error_code": 0,
      "error_text": "ok",
      "id": 4713
    }

The "reply" element specifies that this is the final reply for 4711 transaction.<br>
The "error_code" element specifies the numerical error code.<br>
The "error_text" element contains a textual description of the error.<br>
The "id" element is the transaction ID tag from the request.

If a backend server wants to execute this RPC on all devices that are members of
"some_group", it would send the follwing JSON call to the DM.

    {
      "rpc-request": "some_group/1:a/b/c/random",
      "params": {
        "Val1": 2.0,
        "Val2": 4.0
      },
      "id": 4714,
      "ttl": 3600,
      "reply-url": "http://client_backend.com:/reply-handler"
    }


The "rpc-request" element specifies the complete path to the configuration
entry containing the call to execute.<br>
The "params" contains the input parameters to the RPC.<br>
The "id" specifies the transaction ID to tag the reply (below) with.<br>
The "ttl" specifies the time to live (in seconds) for the call. If it has not been executed
within that period of time, it shall be timed out.

The DM will immediately respond to the backend server with:

    SPLIT INTO SEVERAL REPLIES
    QUERY/STATUS ON TRANSACTIONS.

    {
      "rpc-reply": "queued",
      "devices": [ "dev1", "dev2", "dev3" ]
      "id": 4714,
    }

The "rpc-reply" element's "queued" value indicates that the requst is queued for execution on the DM.<br>
The "devices" array contains the device id of all devices that the rpc has been queued to.<br>
The "id" is the transaction id tag from the request.

When any of the devices that are to execute becomes available to the DM, the DM will instruct the
device to execute the given code pushed out in the "set" operation above. The result of the
RPC call will be sent back to the DM, which will forward it to the backend server.

    {
      "rpc-reply": "intermediate",
      "device": "dev1",
      "result": {
         "Sum": 6.0,
         "Average: 3.0
      },
      "error_code": 0,
      "error_text": "ok",
      "id": 4714,
    }

The "rpc-reply" element's "intermediate" value indicates that this is an intermediate reply and that more will come<br>
The "device" (singular) element specifies which device the RPC reply is from.<br>
The "result" element contains the output from the erlang code exeucution on the given device.<br>
The "error_code" element specifies the numerical error code.<br>
The "error_text" element contains a textual description of the error.<br>
The "id" is the transaction id tag from the request.

A similar reply will be sent when the reply is received from "dev2".

If "dev3" did not become available to execute the RPC within the timeout specified by the "ttl" element in the RPC request, the following reply will be sent back by the DM to the backend server.

    {
      "dm-rpc-reply": "final",
      "device-rpc-reply": "final/intermediate",
      "device": "dev3",
      "result": nil,
      "error_code": 1,
      "error_text": "timeout",
      "id": 4714,
    }

The "rpc-reply" element's "final value indicates that this is the last reply for transaction 4711 (since both dev1 and dev2 have been replied to earlier).<br>
The "device" (singular) element specifies which device the RPC reply is from.<br>
The "result" element is nil since this RPC execution failed.<br>
The "error_code" element specifies the numerical error code.<br>
The "error_text" element contains a textual description of the error.<br>
The "id" is the transaction id tag from the request.


- <b>Server Monitor Entry</b><br>


- <b>Device Monitor Entry</b><br>


##
# Use cases #


# JSON syntax #

